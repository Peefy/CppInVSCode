
# C++题目汇总

1. C++和C的区别

C语言是面向过程的编程，它最重要的特点是函数，通过main函数来调用各个子函数。程序运行的顺序都是程序员事先决定好的。C++是面向对象的编程，类是它的主要特点，在程序执行过程中，先由主main函数进入，定义一些类，根据需要执行类的成员函数，过程的概念被淡化了（实际上过程还是有的，就是主函数的哪些语句），以类驱动程序运行，类就是对象，所以我们称之为面向对象程序设计。面向对象在分析和解决问题的时候，将涉及到的数据和数据的操作封装在类中，通过类可以创建对象，以事件或消息来驱动对象执行处理。

C语言和C++的最大区别在于它们解决问题的思想方法不一样。C语言主要用于嵌入式领域，驱动开发等与硬件直接打交道的领域， C++可以用于应用层开发，用户界面开发等于操作系统打交道的领域。

C++比C类型检查更为严格。增加了面向对象的机制。增加了泛型编程的机制（Template）。增加了异常处理。增加了运算符重载。增加了标准模板库（STL）。增加了命名空间，避免全局命名冲突。

**C++与C不兼容的地方**

* **变量声明的位置**:C中变量声明和代码是分开的，必须在函数开始处声明；C++中，变量可以在任意处声明，只要保证先声名后使用的原则就可以。
* **struct结构体方面**：用struct定义变量。struct mystruct{ int i;float x;在c中声明struct变量要这么写：struct mystruct a;在C++中前面不用加struct：mystruct a;一种兼容的用法是：typedef struct _mystructint i;float x;} mystruct;然后用mystruct 定义变量。枚举型(enum),联合体类型(union)也是同样。
在C++中，struct结构体支持成员函数的定义，C中不行。另外要注意的是，C++中成员函数的默认访问说明符为public,这一点和类不同，类的默认访问说明符为private.
* **bool类型值**：C++中有bool(或boolean类型);C中可没有这样的bool类型，均为数值类型！需要注意的是真为非零(如：1,5.2,-5,-2等)，假的数值为0。
* **注释的不同**：C中的注释至有一种 /\*......\*/;C++中的注释包含两种/\*......\*/和//。
* **强制数据类型装换**：Ｃ中的强制转化形式为：(类型)变量；
C++中还可以使用:类型(变量)的形式。
* **赋值**：C语言中的赋值只有一中即：=;C++中除了使用=外，还可以使用()。例如：int x(5)；就等于: int x=5;我想这种写法是给C++中对象初始化时初始化属性是对象时使用的，那么对于基本类型也可以使用了。
* **函数**：Ｃ语言中函数没有参数默认值，在C++中函数有参数默认值的概念，注意参数默认值与函数重载的区别。C语言中函数的定义又两种形式，经典形式和标准形式，C++中只支持标准形式。标准形式：int string(int x,float y){......}
经典形式: int string(x,y)int x;float y;{......}
C++的函数必须先声名原型或定义才能使用,因为C++是强数据类型语言,在C语言中,未声名和定义函数之前调用函数是允许的.
* **运算符&和关键字const**：&运算符最基本的含义是取地址，C和Ｃ++中都支持这一语法。但在C++中&还可以表示引用。有了引用的概念后函数调用可以作为左值。例如：int &rtux()......rtux()=5;以上表达式在C++中完全正确，但在C语言中是非法的。const关键字要注意一点不同的就是在C++的类函数中，函数可以声名是可以用const，表示这个函数没有改变类中的任何属性。如：void unchange()const;C不能有这样的生明。
* **extern说明符**：在C语言的某些版本中，可以在程序中多次使用一个全局变量而无需使用extern说明符。但在C++中除定义全局变量外，在其他模块使用应先用extern生明。
* **void指针**：在C语言中void指针可以赋给任何类型的指针，但在C++中，却不行，但可以先进行强制数据类型转换，在赋值。

2. C++ explicit和implicit关键字的作用

*单参数的构造函数尽量声明为explicit，声明必须为显示转换*

C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).

3. static关键字的作用

1.static可以用来隐藏函数和变量:当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性(使用extern就可以)，利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于子函数来讲，static的作用仅限于隐藏

2.保持变量内容的持久(static变量的记忆功能和全局生存期)：存储在静态数据的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围。PS:如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，智能在定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它

3.默认初始化为0(static变量):全局变量也具备这一属性，因为全局变量也存储在静态数据区，内存中所有的字节默认值都是0x00,某些时候这一特点可以减少程序员的工作量。再比如要把一个字符数组当字符串来用,但又觉得每次在字符数组末尾加'\0'太麻烦.如果把字符串定义成静态的，就省去了这个麻烦。

4.static的第四个作用：C++中的类成员声明static：在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类。因此，静态数据成员是类的成员，而不是对象的成员。(1)类的静态成员函数是属于整个类而非类的对象，所以没有this指针，导致仅能访问类的静态数据和静态成员函数;(2)不能将静态成员函数定义为虚函数;(3)由于静态成员声明于类，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，函数地址类型是一个"nonmember函数指针"；(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数,就产生一个意想不到的好处：成为一个callback函数,(5)static并没有增加程序的时空开销，相反还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间;(6)静态数据成员在<定义或说明>时前面加关键字static;(7)静态数据成员是静态存储的，所以必须对它进行*初始化*;(8)静态成员初始化与一般数据化不同,初始化在类体外进行:**\<数据类型\>\<类名\>::\<静态数据成员名\>=\<值\>**;(9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响.

4. 数组和指针的区别

通常情况下，C++中指针和数组是可以混用的，但是，在编写字符数组的时候，可能会出现一定问题

* 数组一旦声明，我们就不能再给它赋值，但是我们可以给指针赋值

* 用指针定义字符串时，指针所指的字符串会被理解为常量字符串，不能修改。数组定义的字符串则可以修改。

* 用sizeof运算符可以计算数组变量的数组大小，但指针指向数组时，只能计算出指针本身大小（单位：字节）

* 字符串的结束符'\0'也被sizeof计算在内，因此字符串类型比内容长1


```c++
class CxString  // 使用关键字explicit的类声明, 显示转换  
{  
public:  
    char *_pstr;  
    int _size;  
    explicit CxString(int size)  
    {  
        _size = size;  
        // 代码同上, 省略...  
    }  
    CxString(const char *p)  
    {  
        // 代码同上, 省略...  
    }  
};  
  
    // 下面是调用:  
  
    CxString string1(24);     // 这样是OK的  
    CxString string2 = 10;    // 这样是不行的, 因为explicit关键字取消了隐式转换  
    CxString string3;         // 这样是不行的, 因为没有默认构造函数  
    CxString string4("aaaa"); // 这样是OK的  
    CxString string5 = "bbb"; // 这样也是OK的, 调用的是CxString(const char *p)  
    CxString string6 = 'c';   // 这样是不行的, 其实调用的是CxString(int size), 且size等于'c'的ascii码, 但explicit关键字取消了隐式转换  
    string1 = 2;              // 这样也是不行的, 因为取消了隐式转换  
    string2 = 3;              // 这样也是不行的, 因为取消了隐式转换  
    string3 = string1;        // 这样也是不行的, 因为取消了隐式转换, 除非类实现操作符"="的重载
```

上面也已经说过了, explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了. 例如: 

explicit关键字只需用于类内的单参数构造函数前面。由于无参数的构造函数和多参数的构造函数总是显示调用，这种情况在构造函数前加explicit无意义。

google的c++规范中提到explicit的优点是可以避免不合时宜的类型变换，缺点无。所以google约定所有单参数的构造函数都必须是显示的，只有极少数情况下拷贝构造函数可以不声明称explicit。例如作为其他类的透明包装器的类。
　　effective c++中说：被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit，鼓励大家遵循相同的政策。

5. 野指针

* 指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。
```c++
char *p; //此时p为野指针
```
* 指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针.
```c++
char *p = new char[10];  //指向堆中分配的内存首地址，p存储在栈区
cin >> p;
delete [] p; //p重新变为野指针
```
* 指针操作超越了变量的作用范围。
```c++
char *p = new char[10]; //指向堆中分配的内存首地址
cin >> p;
cout << *(p+10); //可能输出未知数据
```
*c形式的字符串内存泄露*
```c++
#include<iostream>
using namespace std;
void main()
{
    char *p=new char[3];  //分配三个字符空间，p指向该内存空间
    p="ab";             //此时p指向常量“ab”,而不再是new char分配的内存空间了，从而造成了资源泄漏
    delete []p;         //释放时报错
}
```
*改进版本*：
```c++
#include<iostream>
using namespace std;
void main()
{
    char *p=new char[3];  //分配三个字符空间，p指向该内存空间
    strcpy(p,"ab");      //将"ab"存储到p指向的内存空间
    delete []p;         //ok
}
```
* 内存越界
```c++
char *p=new char[3];  //分配三个字符空间，p指向该内存空间
strcpy(p,"abcd");    //将abcd存处在分配的内存空间中，由于strlen("abcd")=4>3，越界
delete []p;         //ok
```
* 返回值是指针：可以使用常量字符串和静态数组将字符串存到静态存储区和文字常量区
```c++
#include<iostream>
using namespace std;
char *f()
{
    char p[]="abc";
    return p;
}
void main()
{
    cout<<f()<<endl;
}
```
* 指针做形参：所谓的地址传递，我们都知道地址传递的方式，形参的改变会导致实参的改变，但要注意的是，这里的改变是指指针所指内容的改变，而不是指针值的改变。因此，当形参改变会导致实参改变时，指针所指的内容是非const类型的，否则会出错。

*注意：p="ab"和strcpy(p,"ab")，含义不一样，前者指针p指向常量“ab”存储区域的首地址，改变了p最开始指向的new申请的内存空间；而后者是将“ab”分配到new申请的内存空间中；*

6. 智能指针的内存泄露问题

7. C/C++ 中 右引用，左引用和指针的区别

8. 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数

9. c++ fork函数

10. 析构函数的作用

11. 静态函数和虚函数的区别

12. 重载和覆盖

13. strcpy和strlen

14. 虚函数和多态

15. ++i和i++的区别

16. c++ 定义常量。常量存放在内存的哪个位置

17. const修饰成员函数的目的

18. c++ 隐式类型转换

19. c++ 函数栈空间的最大值

20. extern “C”

21. new/delete与malloc/free的区别

22. RTTI

23. 虚函数在运行时如何实现多态

24. c语言怎么实现函数调用

25. c语言参数压栈顺序

26. 请你说说C++如何处理返回值？

27. 请你回答一下C++中拷贝赋值函数的形参能否进行值传递？

28. 请你说一说select

29. 请你说说fork,wait,exec函数

30. 请你回答一下静态函数和虚函数的区别

31. 

32. 

33. 

34. 

35. 

36. 

37. 

38. 

39. 

40. 

41. 

42. 

43. 

44. 

45. 

46. 

47. 

48. 

49. 

50. 

51. 

52. 

53. 

54. 

55. 

56. 

57. 

58. 

59. 
